version "4.5"

class DefilerHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'Lumberjack':
				if (random[defrand]() <= 64)
				{
					e.Replacement = "HDDefiler";
				}
				break;
		}
	}
}

class HDDefiler : HDWeapon
{
	enum DefilerProperties
	{
		DFProp_Flags, 
		DFProp_Blood
	}

	override void Tick()
	{
		if (IsFrozen())
		{
			return;
		}

		Super.Tick();

		if (!owner)
		{
			Bloodied = false;
		}

		if (GetAge() % 35 == 0)
		{
			WeaponStatus[DFProp_Blood] = max(-200, WeaponStatus[DFProp_Blood] - 1);
			bUNDROPPABLE = WeaponStatus[DFProp_Blood] < 0;
			let plr = HDPlayerPawn(owner);
			if (plr && WeaponStatus[DFProp_Blood] < 0)
			{
				if (--ChantTicker <= 0)
				{
					plr.A_SetBlend("7a 3a 18", 0.2, 4);
					plr.A_MuzzleClimb((0, frandom(1.0, 1.5)), (0, 0), (0, 0), (0, 0));
					plr.A_StartSound(plr.medsound, CHAN_VOICE);
					plr.A_StartSound("Defiler/Chant", 20, CHANF_LOCAL, 0.5, pitch: frandom(1.0, 1.15));
					ChantTicker = 120;
				}
				else
				{
					plr.bloodloss += int(ceil(abs(WeaponStatus[DFProp_Blood]) / 40.0) * (plr.regenblues > 0 ? 3 : 1));
				}
			}
		}
	}

	override void DetachFromOwner()
	{
		owner.A_TakeInventory('DefilerPassiveSpeed');
		owner.A_TakeInventory('DefilerPassiveInvisibility');
		Super.DetachFromOwner();
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return 1; }
	override double WeaponBulk() { return 10; }
	override string, double GetPickupSprite() { return "DFLRZ0", 0.50; }
	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Stab\n"
		..WEPHELP_ALTFIRE.."  Assassinate\n"
		..WEPHELP_ZOOM.."+"..WEPHELP_FIRE.."  Stab yourself (hold to feed)";
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		sb.DrawRect(-16, -16, -6, 3);
		sb.DrawRect(-22, -18, -1, 7);
		sb.DrawRect(-23, -17, -13, 5);
		sb.DrawRect(-36, -16, -2, 3);
		sb.DrawRect(-38, -15, -2, 1);
		sb.DrawWepNum(max(0, hdw.WeaponStatus[DFProp_Blood]), MaxBlood, alwaysprecise: true);
	}

	action bool A_Stab(double dmg)
	{
		FLineTraceData data;
		bool hasStabbed = LineTrace(angle, 56, pitch, TRF_NOSKY, offsetz: height - 12, data: data);
		if (!hasStabbed)
		{
			return false;
		}

		LineAttack(angle, 56, pitch, data.HitLine ? (CheckInventory('PowerStrength', 1) ? random(50, 120) : random(5, 15)) : 0, "None", CheckInventory('PowerStrength', 1) ? 'DefilerPuffBig' : 'DefilerPuffSmall', flags: LAF_NORANDOMPUFFZ | LAF_OVERRIDEZ, offsetz: height - 12);

		if (!data.HitActor)
		{
			return data.HitLine != null || data.HitSector != null;
		}

		Actor pActor = data.HitActor;
		dmg += HDMath.TowardsEachOther(self, pActor) * 2;

		int hswing = player.cmd.yaw >> 5;
		int vswing = player.cmd.pitch >> 5;
		if (hswing <= 0)
		{
			dmg += min(max(abs(hswing), abs(vswing)), dmg * 2);
		}

		if (pos.z > floorz)
		{
			dmg *= 0.5;
		}

		dmg *= frandom(0.9, 1.2);

		let plr = HDPlayerPawn(self);
		if (plr && !pActor.bDONTTHRUST && (pActor.mass < 200 || pActor.radius * 2 < pActor.Height && data.HitLocation.z > pActor.pos.z + pActor.Height * 0.6))
		{
			double iyaw = player.cmd.yaw * (65535.0 / 360.0);
			if (abs(iyaw) > 0.5)
			{
				pActor.A_SetAngle(clamp(Normalize180(pActor.angle - iyaw * 100), -50, 50), SPF_INTERPOLATE);
			}
			double ipitch = player.cmd.pitch * (65535.0 / 360.0);
			if (abs(ipitch) > 0.5 * 65535.0 / 360.0)
			{
				pActor.A_SetPitch(clamp((pActor.angle + ipitch * 100) % 90, -30, 30), SPF_INTERPOLATE);
			}
		}

		if (!pActor.bNOPAIN && pActor.Health > 0 && !(pActor is "HDBarrel") && data.HitLocation.z > pActor.pos.z + pActor.height * 0.75)
		{
			if (hd_debug)
			{
				A_Log("HEAD SHOT");
			}
			HDMobBase.ForcePain(pActor);
			dmg *= frandom(1.75, 2.0);
		}

		if (hd_debug)
		{
			A_Log(string.format("Stabbed %s for %i damage!", pActor.GetClassName(), dmg));
		}
		if (dmg * 2 > pActor.Health)
		{
			pActor.A_StartSound("Defiler/Stabbity", CHAN_AUTO);
		}

		if (pActor is 'HDHumanoid' && pActor.Health > 0)
		{
			invoker.WeaponStatus[DFProp_Blood] = int(min(MaxBlood, invoker.WeaponStatus[DFProp_Blood] + dmg * 0.85));
			invoker.Bloodied = true;
			A_CheckKnifeFrame();
		}

		if (invoker.Assassination)
		{
			dmg *= 4;
		}

		pActor.DamageMobj(invoker, self, int(dmg), 'Melee');
		return true;
	}

	private action void A_HighlightTarget()
	{
		FLineTraceData data;
		LineTrace(angle, HDCONST_ONEMETRE * 15, pitch, TRF_NOSKY | TRF_THRUHITSCAN | TRF_THRUBLOCK, height - HDCONST_CROWNTOEYES, data: data);
		if (A_IsValidTarget(data.HitActor))
		{
			for (int i = 0; i < 2; ++i)
			{
				data.HitActor.A_SpawnParticle("DarkRed", SPF_RELATIVE | SPF_FULLBRIGHT, random(20, 35), random(4, 12), random(0, 360), random(-16, 16), 0, height + 5 + random(8, -8), 0, 0, frandom(-1.0, -3.0), 0, 0, -0.3);
			}
		}
	}

	private action void A_Assassinate()
	{
		FLineTraceData data;
		LineTrace(angle, HDCONST_ONEMETRE * 15, pitch, TRF_NOSKY | TRF_THRUHITSCAN | TRF_THRUBLOCK, height - HDCONST_CROWNTOEYES, data: data);
		if (!A_IsValidTarget(data.HitActor))
		{
			return;
		}

		vector3 oldPos = pos;
		if (Warp(data.HitActor, -(data.HitActor.radius + radius + 4), 0, 0, 0, WARPF_INTERPOLATE))
		{
			double newAngle = angle;
			double newPitch = pitch;
			vector3 newPos = pos;

			SetXYZ(oldPos);
			A_Face(data.HitActor, 0, 0);

			// [Ace] And now we do a little hacking. I can't into vector math.
			A_RailAttack(0, 0, 0, "", "", RGF_SILENT | RGF_NOPIERCING | RGF_CENTERZ, 1.0, null, spawnclass: 'DefilerTrailParticleSpawner');

			SetXYZ(newPos);
			angle = newAngle;
			pitch = newPitch;

			let plr = HDPlayerPawn(self);
			if (invoker.WeaponStatus[DFProp_Blood] >= 50)
			{
				invoker.WeaponStatus[DFProp_Blood] -= 50;
			}
			else
			{
				plr.bloodloss += plr.regenblues > 30 ? 100 : 50;
			}

			A_StartSound("Defiler/Assassinate", 7);
			A_StartSound("Defiler/Assassinate", 7, CHANF_OVERLAP);
			invoker.Assassination = true;
			SetWeaponState('Fire');
		}
	}

	private action void A_CheckKnifeFrame()
	{
		let psp = player.GetPSprite(PSP_WEAPON);
		psp.frame = int(invoker.Bloodied);
	}

	private action bool A_IsValidTarget(Actor a)
	{
		if (!(a is 'HDHumanoid' || a is 'Serpentipede'))
		{
			return false;
		}

		double dist = a.radius + radius + 4;
		return level.IsPointInLevel(a.Vec3Angle(-dist, 0)) && !a.InStateSequence(a.CurState, a.FindState('falldown')) && a.Health > 0 && Distance3D(a) < HDCONST_ONEMETRE * 10 && !a.bFRIENDLY && Warp(a, -dist, 0, 0, 0, WARPF_INTERPOLATE | WARPF_TESTONLY);
	}

	const MaxBlood = 900;
	private bool HasAttacked;
	private bool Bloodied;
	private int ChantTicker;
	private bool Assassination;
	private int TotalSchlorped;

	Default
	{
		+WEAPON.MELEEWEAPON
		+WEAPON.NOALERT
		+WEAPON.NO_AUTO_SWITCH
		+FORCEPAIN
		+HDWEAPON.DONTDISARM
		+AMBUSH
		Obituary "%o got %p blood drained by %k.";
		Inventory.PickupMessage "Picked up the the demon knife.";
		Inventory.PickupSound "weapons/pocket";
		Weapon.SelectionOrder 100;
		Weapon.Kickback 50;
		Weapon.BobStyle "Alpha";
		Weapon.BobSpeed 2.6;
		Weapon.BobRangeX 0.1;
		Weapon.BobRangeY 0.5;
		Weapon.SlotNumber 1;
		Weapon.SlotPriority 2;
		Scale 0.3;
		Tag "Defiler";
		HDWeapon.Refid "dfl";
	}

	States
	{
		Spawn:
			DFLR Z -1;
			Stop;
		Ready:
			DFLR A 1
			{
				A_CheckKnifeFrame();
				if (!PressingFire() && !PressingAltfire())
				{
					invoker.HasAttacked = false;
				}
				let plr = HDPlayerPawn(self);

				int flgs = WRF_ALL;
				if (invoker.HasAttacked)
				{
					flgs |= WRF_NOFIRE;
				}
				A_WeaponReady(flgs);
				A_HighlightTarget();

				let psp = player.GetPSprite(PSP_WEAPON);
				if (psp.rotation < 15 * 2)
				{
					A_OverlayPivotAlign(PSP_WEAPON, PSPA_CENTER, PSPA_CENTER);
					A_OverlayRotate(PSP_WEAPON, 15, WOF_ADD);
				}

				if (plr.zerk > 0 && !invoker.bUNTOSSABLE)
				{
					invoker.bUNTOSSABLE = true;
					plr.A_StartSound("misc/bulletflesh", CHAN_AUTO);
					A_MuzzleClimb(frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(0.0, 1.0));
				}
				else if (plr.zerk <= 0 && invoker.bUNTOSSABLE)
				{
					invoker.bUNTOSSABLE = false;
					plr.A_StartSound("misc/bulletflesh", CHAN_AUTO);
					A_MuzzleClimb(frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(0.0, 1.0));
					plr.woundcount += 3;
				}
			}
			Goto ReadyEnd;
		Select0:
			DFLR A 0
			{
				A_CheckKnifeFrame();
				A_GiveInventory('DefilerPassiveSpeed');
				A_GiveInventory('DefilerPassiveInvisibility');
				A_StartSound("Defiler/Unsheathe", CHAN_WEAPON);
			}
			DFLR # 1 A_Raise(16);
			Wait;
		Deselect0:
			DFLR A 0
			{
				A_TakeInventory('DefilerPassiveSpeed');
				A_TakeInventory('DefilerPassiveInvisibility');
				invoker.bUNTOSSABLE = false;
				A_CheckKnifeFrame();
			}
			DFLR # 1 A_Lower(16);
			Wait;
		Fire:
		Hold:
		AltHold:
			#### # 0 A_JumpIf(PressingZoom(), 'Sudoku');
			#### # 0 A_WeaponBusy(true);
			#### # 1
			{
				A_StartSound("Defiler/Swing", CHAN_WEAPON);
				invoker.HasAttacked = true;
				A_OverlayRotate(PSP_WEAPON, 0);
				A_WeaponOffset(60, 0, WOF_KEEPY);
				bool success = A_Stab((CheckInventory('PowerStrength', 1) ? 150 : 60));
				if (success)
				{
					SetWeaponState('Stab');
				}
				invoker.Assassination = false;
			}
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, -20);
				A_WeaponOffset(120, 0, WOF_KEEPY);
			}
			#### # 2;
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, -10);
				A_WeaponOffset(50, 0, WOF_KEEPY);
			}
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, -5);
				A_WeaponOffset(20, 0, WOF_KEEPY);
			}
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, 0);
				A_WeaponOffset(0, 0, WOF_KEEPY);
			}
			Goto Ready;
		Stab:
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, -10);
				A_WeaponOffset(80, 0, WOF_KEEPY);
			}
			#### # 8 A_SetTics(CheckInventory('PowerStrength', 1) ? 3 : 8);
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, -5);
				A_WeaponOffset(50, 0, WOF_KEEPY);
			}
			#### # 1
			{
				A_OverlayRotate(PSP_WEAPON, 0);
				A_WeaponOffset(25, 0, WOF_KEEPY);
			}
			#### # 0 A_WeaponBusy(false);
			Goto Ready;
			
		AltFire:
			#### # 0 A_JumpIf(PressingZoom(), 'Sudoku');
			#### # 0 A_Assassinate();
			Goto Fire;
		Sudoku:
			#### # 1;
			#### # 0
			{
				if (!CheckInventory('WornRadsuit', 0))
				{
					if (pitch < 55)
					{
						A_SetPitch(pitch + 8, SPF_INTERPOLATE);
						A_Refire('AltFire');
						return;
					}
					else
					{
						SetWeaponState('Ouchie');
						return;
					}
				}
			}
			Goto Nope;
		Ouchie:
			#### # 0 A_WeaponBusy(true);
			#### ### 1
			{
				A_WeaponOffset(0, 20, WOF_ADD);
				A_OverlayRotate(PSP_WEAPON, -30, WOF_ADD);
			}
			TNT1 A 5;
			#### # 0
			{
				invoker.Bloodied = true;
				A_CheckKnifeFrame();
				let plr = HDPlayerPawn(self);
				A_SetBlend("7a 3a 18", 0.2, 4);
				A_MuzzleClimb(0, frandom(1.0, 1.5));
				A_StartSound("Defiler/Stabbity", CHAN_WEAPON);
				A_StartSound("Defiler/Stabbity", CHAN_WEAPON, CHANF_OVERLAP);
				A_StartSound(plr.medsound, CHAN_VOICE);

				int toInflict = int(random(2, random(4, (!random(0, 2) ? 15 : 8))));
				if (plr.regenblues > 30)
				{
					toInflict *= 4;
				}
				plr.woundcount += toInflict;
			}
		Schlorp:
			#### # 20;
			#### # 0 A_JumpIf(!PressingFire() || invoker.WeaponStatus[DFProp_Blood] > MaxBlood - 10, 'EndSchlorp');
			#### # 0
			{
				let plr = HDPlayerPawn(self);
				int toFeed = random(40, 60);
				invoker.WeaponStatus[DFProp_Blood] = min(MaxBlood, invoker.WeaponStatus[DFProp_Blood] + toFeed);
				invoker.TotalSchlorped += toFeed;
				if (invoker.TotalSchlorped > 150)
				{
					A_GiveInventory("DefilerHealing");
					GiveBody(15);
					invoker.TotalSchlorped = 0;
				}
				plr.bloodloss += toFeed * (plr.regenblues > 30 ? 2 : 1);
				A_StartSound("Defiler/Schlorp", CHAN_WEAPON, pitch: frandom(0.9, 1.2));
			}
			Loop;
		EndSchlorp:
			TNT1 A 15;
			DFLR # 0
			{
				A_CheckKnifeFrame();
				A_OverlayRotate(PSP_WEAPON, 0);
			}
			#### ### 1
			{
				A_WeaponOffset(0, -20, WOF_ADD);
			}
			#### # 0 A_WeaponBusy(false);
			Goto Nope;
	}
}

class DefilerHealing : Powerup
{
	override void DoEffect()
	{
		Super.DoEffect();
		let plr = HDPlayerPawn(owner);
		if (!plr)
		{
			return;
		}

		plr.beatmax = min(plr.beatmax, 10);
		plr.bloodpressure = max(plr.bloodpressure, 50);
		if (plr && plr.beatcount == 0)
		{
			plr.GiveBody(5);
			plr.stunned = max(0, plr.stunned - 35);
		}
	}

	Default
	{
		+INVENTORY.ALWAYSPICKUP
		Powerup.Duration -30;
	}
}

class DefilerPassiveSpeed : PowerSpeed
{
	Default
	{
		Speed 1.33;
		Powerup.Duration 0xFFFFFF;
	}
}

class DefilerPassiveInvisibility : PowerInvisibility 
{
	Default
	{
		Powerup.Duration 0xFFFFFF;
		Powerup.Mode "Cumulative";
	}
}

class DefilerPuffBase : Actor abstract
{
	Default
	{
		+NOINTERACTION
		+ALLOWTHRUFLAGS
		+MTHRUSPECIES
		+PUFFGETSOWNER
		+NOEXTREMEDEATH
		DamageType "Melee";
		AttackSound "Defiler/WallImpact";
	}
}

class DefilerPuffSmall : DefilerPuffBase
{
	Default
	{
		Decal "DefilerSlashSmall";
	}
}

class DefilerPuffBig : DefilerPuffBase
{
	Default
	{
		Decal "DefilerSlashBig";
	}
}

class DefilerTrailParticleSpawner : Actor
{
	Default
	{
		+NOBLOCKMAP
		+NOINTERACTION
	}

	States
	{
		Spawn:
			TNT1 A 1 NoDelay
			{
				A_SpawnParticle(0xFF0000, SPF_RELATIVE | SPF_FULLBRIGHT, random(35, 60), frandom(2.0, 5.0), 0, 0, random(-10, 10), random(-20, 20), frandom(-0.1, 0.1), frandom(-0.5, 0.5), frandom(-0.5, 0.5), 0, frandom(-0.01, 0.01), frandom(-0.01, 0.01));
			}
			Stop;
	}
}